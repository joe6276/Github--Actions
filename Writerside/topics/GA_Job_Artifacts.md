# Job Artifacts
 
Job artifacts are the assets/ output generated by a job.
![Build Job](image_11.png)

Starting Workflow:
```yaml

name: Deploy website
on:
  push:
    branches:
      - master

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Install dependencies
        run: npm ci
      - name: Lint code
        run: npm run lint
      - name: Test code
        run: npm run test

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Install dependencies
        run: npm ci
      - name: Build website
        run: npm run build

  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Deploy
        run: echo "Deploying..."

```

The above has three jobs a test, build and deploy. But let's focus on the build job because when the _npm run build_ command is executed, it produces a 
dist file which id the file that is uploaded to a web server.

The problem is when we execute the script as it is right now, when the runner is done, it will shut down, and we will lose the files generated 
by the job.


So let's modify this, on the Build steps let's modify the code.

```yaml
  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v3
      - name: Install dependencies
        run: npm ci
      - name: Build website
        run: npm run build
      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist
```

## Explanation 

```yaml
- name: Upload Artifacts
  uses: actions/upload-artifact@v4
```
We will give the step a name and specify that we are going to use an existing action which helps us upload the artifacts.

```yaml
   with:
       name: dist-files
       path: dist
```
we will give it a name, in this case its _dist-files_, and we will specify the path the files will be uploaded from _dist_ .

and now in your workflow, you should be able to see and download the files:
![Artifacts](image_12.png)


But we need to use the files in the deployment job. The files produced by the build process  
will not persist to the deployment job because they are on different runners even though
 they use the same runner definition. To get the artifacts, we need to download them in the deployment step.
Let's modify the deployment job

```yaml
  deploy:
    needs: build
    runs-on: ubuntu-latest
    steps:
      - name: Download build Artifacts
        uses: actions/download-artifact@v4
        with:
          name: dist-files
      - name: Output content
        run: ls    
      - name: Deploy
        run: echo "Deploying..."
```

We will add the download artifact action and specify the names of the files to be downloaded, in this case
its _dist-files_ which is the same name we used in the build step.

The action here will download and unzip the files:
And we can now use the 'ls' step to list the contents.
 
Now we can see the output right here:
![Download content](image_13.png)

## Dependencies Caching 
![Step Time](image_14.png)
If we take a look at the build step, we will notice that the step that takes more time is the dependency
installation step. Also, we will notice that we have repeated the step in both test and build job.

We can save some time if we cache the dependencies and reuse then in the build step.
![Cache](image_15.png)

GitHub Action has an action that will help us cache the dependencies

```yaml
      - name: Cache Dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: deps-node-modules- ${{hashFiles('**/package-lock.json')}}
```
This will now cache the dependencies and will only run _npm ci_ if the package.lock.json file has changed so that means
we will be able to use cache for every step provided the package-lock.json file has not changed.


Now the workflow file will look like:
```yaml

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v4
      - name: Cache Dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: deps-node-modules- ${{hashFiles('**/package-lock.json')}}
      - name: Install dependencies
        run: npm ci
      - name: Lint code
        run: npm run lint
      - name: Test code
        run: npm run test

  build:
    needs: test
    runs-on: ubuntu-latest
    steps:
      - name: Get code
        uses: actions/checkout@v4
      - name: Cache Dependencies
        uses: actions/cache@v4
        with:
          path: ~/.npm
          key: deps-node-modules- ${{hashFiles('**/package-lock.json')}}
      - name: Install dependencies
        run: npm ci
      - name: Build website
        run: npm run build
      - name: Upload Artifacts
        uses: actions/upload-artifact@v4
        with:
          name: dist-files
          path: dist
```

Now you will notice that the Cache is used for the second Job (build). And cache will be used, hence it will be a bit faster.
![Caching](image_16.png)